#+TITLE: 【STL】map & hash_map
#+AUTHOR: 卷摸

#+html_head: <link rel="stylesheet" href="../org.css">
#+options: ^:nil

本文的作者是 *深深爱着人类* 的【我】。

这篇文章说说 C++ 标准模板库 STL 中的关联容器 map，以及它 C++11 中增加亲戚的 unordered_map（即 hash_map）。

我建立了个人网站【momo9.me】，大家多去我那看看吧。点击『阅读原文』可以访问哈~

-----

#+begin_quote
《STL 源码剖析》 侯捷
#+end_quote

上一篇文章介绍的两种容器（vector 与 deque）是能够随机访问的顺序容器。因为容器内的数据按顺序存储，且每个数据的大小都一致，因此，通过数据的 *下标* 来访问数据，访问时只需要根据下标计算数据与容器首地址的偏移量，时间复杂度为 /O(1)/ 。下图以数组（也可以认为是一种能够随机访问的顺序容器）为例，介绍这一访问过程，vector 与 deque 的随机访问没有这么简单，但原理是类似的。我们通常使用 =a[2]= 来访问 D2，其实际行为是 =*(a + 2)= ，即取与数组 a 首地址偏移量为 2 的地址中的数据。实际上，在 C 语言中， =x[y]= 只是 =*(x + y)= 的语法糖，因此我们用 =2[a]= 同样可以访问 D2。

[[./array.gif]]

显然，顺序容器这样简单的数据结构并不足以抽象复杂的现实世界，至少，在很多情况下，使用顺序容器是不够直观的。例如，如果用顺序容器来抽象一篇文章，我们固然可以使用下标为 0 的数据表示标题，下标为 1 的数据表示作者，下标为 2 的数据表示分类，但这样的抽象实在太不直观，很容易弄错。我们需要这样一种容器， *能够通过比下标具有更强特征的标识来访问数据* 。这样的容器就是关联容器。关联容器中的数据都有一个 *键值* ，每个数据的键值都是独一无二的，通过键值，能够访问到容器中对应的唯一数据。这个键值可以为任意类型（通常是字符串），具有很强的特征性。如果用关联容器来抽象一篇文章，就可以通过键值 =标题= 来访问文章的标题，通过键值 =作者= 来访问文章的作者，通过键值 =分类= 来访问文章的分类。

[[./seq&ass.gif]]

关联容器带来了很大的方便，但实现的难度要比顺序容器更大。毕竟，键值可以为任意类型，不像下标那样可以通过简单的加法运算就定位到所需的数据。STL 如何设计数据结构，使得关联容器能够快速地通过键值定位到对应的数据，是本文要说明的主要内容。

* map

STL map 使用的数据结构是二叉查找树（Binary Search Tree，BST），更具体一点说，是红黑树。

简单说一下 BST。这种二叉树中，任意一个节点左子树中所有节点的值都小于该节点的值，任意一个节点右子树中所有节点的值都大于该节点的值。显然，在 BST 中查找一个值应从根节点开始，如果待查找的值小于根节点的值的话，就去左子树中查找；如果待查找的值大于跟节点的值的话，就去右子树中查找。如果这棵 BST 比较平衡，也就是说叶节点的高度都差不多的话，在 BST 中查找一个值的时间复杂度应与树的高度成正比，为 /O(lgn)/ 。

[[./bst.gif]]

BST 中的节点是有序的。对 BST 作中序遍历的话，将得到 BST 中所有节点的值按顺序排列后的序列。而且，给出 BST 中的任意一个节点，能够很容易地找到其（按顺序排列时的）前一个节点与后一个节点（称为【前驱】与【后继】）。

对应到 map 的实现上就是说，map 中的各个元素组成了一棵 BST，其中任意元素的左子树中所有元素的键值都小于该元素的键值，右子树中所有元素的键值都大于该元素的键值。而且因为 BST 中的节点是有序的，很容易根据键值对 map 中的元素进行排序。

之前我们说过，当 BST *比较平衡* 时，在 BST 查找节点的时间复杂度为 /O(lgn)/ 。而当 BST 不平衡，比如出现下面这种最坏情况时，查找的时间复杂度可为 /O(n)/ ，这样的性能和把数据直接无序地放置在链表中没有区别。 *可见，保证 BST 的平衡，是保证 BST 性能的关键。* STL map 中采用的 BST 为红黑树，这种 BST 无论经过怎样的插入与删除操作，都能够处在一种较为平衡的状态（并非绝对的平衡），保证了性能。至于红黑树的具体原理比较复杂，我没有想到很好的办法在几句话内比较直观地描述其特性，这里就不具体介绍了。

[[./unbalanced.gif]]

* unordered_map（hash_map）

map 是基于树的关联容器。存储于其中的数据是有序的，且查找的复杂度为 /O(lgn)/ 。可是仔细一想，这样的 map 其实并不实用：在很多场景下，我们需要的只是能够通过 /键值/ 来访问数据的容器，至于数据是否有序，这其实无关紧要；map 保证了数据的有序，却需要 /O(lgn)/ 的查找复杂度，因此并不实用。

那么是否有查找复杂度更低（ /O(1)/ ，常数复杂度）的关联容器呢？让我们回想一下，能够通过下标来访问数据的 vector（或者说数组）具有 /O(1)/ 的访问复杂度。因此，如果我们能够建立起 *键值与下标（一个数字）之间的映射* ，并在容器内部采用 vector 的结构，就能够实现一个具有 /O(1)/ 查找复杂度的关联容器。

hash_map，也就是 C++11 中新加入的 unordered_map，正是采用了上述的办法。unordered_map 虽无法保证数据的有序，但具有 /O(1)/ 的查找复杂度。

** 键值与数字的映射

我们需要怎样的映射呢？

1. 能够将键值映射为数字，键值可能是任意类型
2. 映射要快，如果映射非常复杂，性能的瓶颈就从查找速度变为映射速度，没有意义
3. 映射后数字的范围要和键值的数量匹配：如果只有两个键，但其中一个键映射出的数字是两亿，就需要一个大小为两亿的 vector 来保证常数的访问时间，这样的空间消耗是不划算的
4. 尽量能够将不同的键值映射为不同的数字，避免冲突

基本上，能符合上述条件的映射（也许并不是太准确的定义），我们称之为 *hash 函数* ，中文名 *散列函数* 。关于 hash 函数的设计，是一个很复杂的话题，这里不再进行深入讨论。

** 冲突的解决

上述的第 4 点，其实是很难保证的，再加上第 3 点的约束，出现冲突几乎难以避免。STL 解决这一问题的方法是 /开链法/ 。

假设 hash 函数定义了如下的映射关系：

- 标题 -> 2
- 分类 -> 2
- 作者 -> 1

可以看到，“标题”与“分类”两个键的 hash 值是冲突的，这时候 hash_map 的样子如下图所示：hash_map 内 vector 的每个单元（在 hash_map 中，通常称为 *桶* ）中存储的并不是数据本身，而是一个链表。所有 hash 值相同的键值对应的数据，都被存储在相应的链表中。查找时，首先会根据键值的 hash 值定位到相应的链表，定位链表的时间复杂度是 /O(1)/ 。在定位到链表后，再在链表中 *顺序查找* ，直到找到键值匹配的数据为止。

[[./hash.png]]

这里有一个问题：定位链表的过程固然很快，但之后在链表中顺序查找，速度是否很慢？当然，如果遇到最坏情况，所有数据的键值的 hash 值都一样，那么 hash_map 就退化为一个链表，查找的复杂度为 /O(n)/ ，性能是很差的。但是，当 hash 函数设计合理的时候，hash_map 中每个链表的长度应该大致相同（且长度和数据总数比应该较小，否则性能也不好），最坏情况是不太可能出现的，起码在 /统计上/ 是如此。
