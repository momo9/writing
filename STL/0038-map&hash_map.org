#+TITLE: 【STL】map & hash_map
#+AUTHOR: 卷摸

#+Style: <link rel="stylesheet" href="../org.css">
#+options: ^:nil

本文的作者是 *深深爱着人类* 的【我】。

这篇文章说说 C++ 标准模板库 STL 中的关联容器 map，以及它 C++11 中增加亲戚的 unordered_map（即 hash_map）。

我建立了个人网站【momo9.me】，大家多去我那看看吧。点击『阅读原文』可以访问哈~

-----

#+begin_quote
《STL 源码剖析》 侯捷
#+end_quote

上一篇文章介绍的两种容器（vector 与 deque）是能够随机访问的顺序容器。因为容器内的数据按顺序存储，且每个数据的大小都一致，因此，通过数据的 *下标* 来访问数据，访问时只需要根据下标计算数据与容器首地址的偏移量，时间复杂度为 /O(1)/ 。下图以数组（也可以认为是一种能够随机访问的顺序容器）为例，介绍这一访问过程，vector 与 deque 的随机访问没有这么简单，但原理是类似的。我们通常使用 =a[2]= 来访问 D2，其实际行为是 =*(a + 2)= ，即取与数组 a 首地址偏移量为 2 的地址中的数据。实际上，在 C 语言中， =x[y]= 只是 =*(x + y)= 的简写，因此我们用 =2[a]= 同样可以访问 D2。

[[./array.gif]]

显然，顺序容器这样简单的数据结构并不足以抽象复杂的现实世界，至少，在很多情况下，使用顺序容器是不够直观的。例如，如果用顺序容器来抽象一篇文章，我们固然可以使用下标为 0 的数据表示标题，下标为 1 的数据表示作者，下标为 2 的数据表示分类，但这样的抽象实在太不直观，很容易弄错。我们需要这样一种容器， *能够通过比下标具有更强特征的标识来访问数据* 。这样的容器就是关联容器。关联容器中的数据都有一个 *键值* ，每个数据的键值都是独一无二的，通过键值，能够访问到容器中对应的唯一数据。这个键值可以为任意类型（通常是字符串），具有很强的特征性。如果用关联容器来抽象一篇文章，就可以通过键值 =标题= 来访问文章的标题，通过键值 =作者= 来访问文章的作者，通过键值 =分类= 来访问文章的分类。

[[./seq&ass.gif]]

关联容器带来了很大的方便，但实现的难度要比顺序容器更大。毕竟，键值可以为任意类型，不像下标那样可以通过简单的加法运算就定位到所需的数据。STL 如何设计数据结构，使得关联容器能够快速地通过键值定位到对应的数据，是本文要说明的主要内容。

* map

STL map 使用的数据结构是二叉查找树（Binary Search Tree，BST），更具体一点说，是红黑树。

简单说一下 BST。这种二叉树中，任意一个节点左子树中所有节点的值都小于该节点的值，任意一个节点右子树中所有节点的值都大于该节点的值。显然，在 BST 中查找一个值应从根节点开始，如果待查找的值小于根节点的值的话，就去左子树中查找；如果待查找的值大于跟节点的值的话，就去右子树中查找。如果这棵 BST 比较平衡，也就是说叶节点的高度都差不多的话，在 BST 中查找一个值的时间复杂度应与树的高度成正比，为 /O(lgn)/ 。而且，对 BST 作中序遍历的话，将得到树中所有值按顺序排列的序列。

[[./bst.gif]]

对于 map 来说，就是。。。

* unordered_map（hash_map）
