#+TITLE: 【STL】vector & deque
#+AUTHOR: 卷摸

#+Style: <link rel="stylesheet" href="../org.css">
#+options: ^:nil

本文的作者是 *深深爱着人类* 的【我】。

这篇文章说说 C++ 标准模板库 STL 中的两种“智能”数组：vector 与 deque。

我建立了个人网站【momo9.me】，大家多去我那看看吧。点击『阅读原文』可以访问哈~

-----

#+begin_quote
《STL 源码剖析》 侯捷
#+end_quote

* vector

关于 vector，能谈的东西不是太多，它几乎和 C/C++ 的原生数组没有太大的区别：能够随机访问，但是插入数据的话，需要将插入位置之后的数据全部向后移动，插入速度较慢，时间复杂度为 /O(n)/ 。不过，vector 解决了原生数组的最不“智能”的一个问题： *数组的大小在程序运行期间不能变化。*

解决的办法，说起来是非常简单粗暴的。vector 的内部管理了一块堆内存（这块堆内存的大小称为 *容量* ）以及目前 vector 内有效数据的数量。如果用户追加数据，或是需要更大的容器，也就是说 *有效数据的大小超过 vector 容量的大小时，* vector 会重新申请一块更大的堆内存进行扩容，并将原有的数据复制到新的内存中，完成数据的追加，再释放原有的堆内存。

[[./vector.jpg]]

*显然，vector 的扩容非常费时，对性能有严重影响。* vector 的容量越大，vector 需要扩容的可能性越小，vector 工作的性能也就比较好；但如果将 vector 容量预留得过大，在空间上又有很大的浪费。在 STL 中， *vector 的容量总是正好能够容纳 2 的整数次幂个元素。* 每当有效数据的数量超过 vector 的容量时，vector 的容量就会扩展为原有容量的 2 倍。vector 通过这种策略，保证扩容不会过于频繁，同时也不至于占用太多的空间。

*出于性能的考虑，当 vector 中的有效数据减少时，vector 并不会减少容量。* 这样的策略是很常见的，比如在实现 =free()= 时，只是把内存放回 =malloc()= 管理的内存池中，而不是交还给操作系统。

* deque

根据上面的介绍，当不需要扩容时，在 vector 尾部追加数据速度很快，时间复杂度为 /O(1)/ ；而在 vector 的头部插入数据则很慢，需要把 vector 中现有的元素全部向后移动，时间复杂度为 /O(n)/ 。然而，有时候既需要频繁地在尾部追加数据，又需要频繁地在头部插入数据（比如队列），这时候使用 vector 的效率就很低。如果使用 list，虽然能够满足对于插入效率的需求，但又无法进行随机访问。这时候，适用的 STL 容器是 deque。deque 的头部插入和尾部追加时间复杂度均为 /O(1)/ ，而且能够进行随机访问。

[[./deque.gif]]

如上图所示，deque 内部是一种 *分级* 的数据结构，由一个大小可能发生变化的内存块 *map* 以及若干大小一致的内存块 *buffer* 构成。map 中每个已使用的单元（图中橙色部分）都指向一个 buffer，而这些 buffer 中，除了首尾两个以外，其它都存满了数据。因此，deque 可以根据 buffer 的大小以及第 1 个 buffer 中内存的使用情况来进行随机访问。在上图中，buffer 的大小为 4 个单元，第 1 个 buffer 中已经使用了 2 个单元，假如需要访问 deque 的第 11 个单元，容易算出实际需要访问的是 map 指向的第 4 个 buffer 的第 1 个单元。

向 deque 插入数据的情况比较复杂，可能发生以下四种可能：

1. 目前已有的 buffer 已经足够， *只需要对 buffer 进行调整* ；
2. buffer 不足， *分配新的 buffer* ；
3. 插入的数据比 2 的情况更多，分配了多个 buffer，导致 map 中使用的单元并不位于 map 的中部，使 map 无法充分地利用内存， *此时需要调整 map，使其重获平衡* ；\\
 [[./balance.gif]]
4. 插入的数据比 3 的情况更多，现有的 map 已经无法装下这些数据， *需要重新分配一个 map ，并将现有数据复制过去* 。

上述四种情况可能性依次递减，而复杂度依次递增。因此，尽管 deque 的某些插入操作很复杂，但因为这些操作的概率较小，插入操作的平均复杂度并不高。而对于我们重点关注的头部插入与尾部追加而言，大部分时候都是发生 1 的情况，时间复杂度为 /O(1)/ 。不过，比起 vector，deque 毕竟更为复杂，除了 /O(1)/ 的头部插入复杂度以外，其它操作的性能几乎都比 vector 更差，如果不需要频繁地进行头部插入的话，并不应该选用 deque。

（本文结束，下一篇是【map & hash_map】）
