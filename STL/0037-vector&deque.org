#+TITLE: 【STL】vector & deque
#+AUTHOR: 卷摸

#+Style: <link rel="stylesheet" href="../org.css">

本文的作者是 *深深爱着人类* 的【我】。

这篇文章说说 C++ 标准模板库 STL 中的两种“智能”数组：vector 与 deque。

我建立了个人网站【momo9.me】，大家多去我那看看吧。点击『阅读原文』可以访问哈~

-----

* vector

关于 vector，能谈的东西不是太多，它几乎和 C/C++ 的原生数组没有太大的区别：能够随机访问，但是插入数据的话，需要将插入位置之后的数据全部向后移动，插入速度较慢。不过，vector 解决了原生数组的最不“智能”的一个问题： *数组的大小在程序运行期间不能变化。*

解决的办法，说起来是非常简单粗暴的。vector 的内部管理了一块堆内存（这块堆内存的大小称为 *容量* ）以及目前 vector 内有效数据的数量。如果用户追加数据，或是需要更大的容器，也就是说 *有效数据的大小超过 vector 容量的大小时，* vector 会重新申请一块更大的堆内存进行扩容，并将原有的数据复制到新的内存中，完成数据的追加，再释放原有的堆内存。

[[./vector.jpg]]

*显然，vector 的扩容非常费时，对性能有严重影响。* vector 的容量越大，vector 需要扩容的可能性越小，vector 工作的性能也就比较好；但如果将 vector 容量预留得过大，在空间上又有很大的浪费。在 STL 中， *vector 的容量总是正好能够容纳 2 的整数次幂个元素。* 每当有效数据的数量超过 vector 的容量时，vector 的容量就会扩展为原有容量的 2 倍。vector 通过这种策略，保证扩容不会过于频繁，同时也不至于占用太多的空间。

*出于性能的考虑，当 vector 中的有效数据减少时，vector 并不会减少容量。* 这样的策略是很常见的，比如在实现 =free()= 时，只是把内存放回 =malloc()= 管理的内存池中，而不是交还给操作系统。

* deque
