#+TITLE: 【STL】Introduction
#+AUTHOR: 卷摸
#+options: ^:nil

#+Style: <link rel="stylesheet" href="../org.css">

本文的作者是 *深深爱着人类* 的【我】。

STL 是 C++ 的标准模板库，这个系列是技术文章。

我建立了个人网站【momo9.me】，大家多去我那看看吧。点击『阅读原文』可以访问哈~

-----

#+begin_quote
《STL 源码剖析》 侯捷
#+end_quote

满分以 10 分记，你给自己的 C++ 水平打多少分呢？一个段子里是这么写的。

#+begin_quote
普通程序员说：4 分。

101011 程序员说：9 分。

文艺的 Stroustrup（C++ 之父）说：7 分。
#+end_quote

讲这个段子是想说，C++ 是一门非常复杂的语言。而学校的课程设置在没有太多课时能够用来教编程的情况下，用 C++ 来作为大家的编程第一课，有挺多缺点的。
1. 比如，没有接触过编程的同学会表示，编程好难
2. 比如，学到的 C++ 是不完全体：《Effective C++》里说，C++ 是由 C、面向对象、模板（泛型）、STL 构成的语言联邦，可课程是按 C 来教的，并附带了一些面向对象的内容，学完之后编出来的 C++ 程序是既非 C 也非 C++ 的四不像

以上内容有点跑偏，其实这个系列的文章只是梳理自己阅读《STL 源码剖析》后学到的东西，介绍一下 SGI STL 背后的实现。当然它和 C++ 的其它部分也不能说没有关系，一方面，作为底层库，免不了要使用 C 的一些元素，比如指针；另一方面，STL 本身就是泛型编程，肯定涉及模板相关的内容。不过，STL 和面向对象的关系就不太大了，STL 甚至不完全支持面向对象：STL 容器的析构函数都不是 =virtual= 的，继承 STL 的容器会有问题。

这个系列将包括以下内容：
1. introduction：就是大家现在看到的这篇引子
2. vector 与 deque ：两种顺序容器
3. map 与 hash_map ：STL 中树与哈希的实现
4. 算法：STL 中个人认为实现得比较巧妙的算法
5. traits：STL 中实现部分反射功能的一种方法
6. allocator ：STL 的内存管理
7. functor：简单说说什么是 functor

从用户的角度来看，我觉得 STL 由两大块构成： _容器_ 与 _算法_ 。其中，容器是用于存储数据的数据结构，算法则是操作容器中数据的一些常用操作。

容器又分为 _顺序容器_ 和 _关联容器_ 。顺序容器的底层数据结构是数组、链表等线性的数据结构，包括 STL 中的 vector、deque 与 list。前两种顺序容器可以认为是工作起来较为智能的数组，但因为它们的实现原理不同，因此各有优缺点。下一篇文章将对这两种容器进行具体的介绍。第三种顺序容器（list）则是我们非常熟悉的双向链表，这个系列的文章就不再对其进行具体的介绍了。

关联容器的底层数据结构则是树与哈希等非线性的数据结构，包括 STL 中的 set 与 map。其中，set 是一系列不重复的元素的集合，map 则是 _键值对_ 。因为 map 的键通常是不能重复的， map 的键的集合是一个 set，因此 set 和 map 在实现上非常相似。STL 标准中的 set 与 map 是基于树实现的，能够保证容器中的元素有序。而很多 STL 实现中也提供了基于哈希的 set 与 map，与基于树的关联容器相比，基于哈希的关联容器具有更快的访问速度，但无法保证容器中的元素有序。这个系列的第三篇文章将介绍关联容器的这两种实现。

这个系列的第四篇文章将介绍 STL 中的算法。由于 STL 中的算法都是通用算法，给我的感觉是原理都比较简单，因此这个系列中只选取其中我个人觉得比较巧妙的算法进行介绍。

STL 中有形形色色的容器，那么算法是怎样做到通用的呢？答案是凭借 _迭代器_ 。迭代器是用于遍历容器的对象。在算法中，仅通过迭代器来遍历容器，实现功能，而不直接访问容器。因此，只要容器提供了合适的迭代器，算法就可以对其进行处理，而不需要了解容器的具体实现是怎样的。迭代器的实现本身比较简单，这个系列将不会做深入的介绍。但在第五篇文章中，将介绍与之相关的一个内容：traits。 _算法通过迭代器实现通用性是很好的事情，但容器毕竟有各自的特性，通用的算法对于一些容器来说是非常低效的。_ 一个折中的办法是对迭代器进行分类，从而根据迭代器类型的不同选择不同的处理方法。然而，C++ 中并没有 Java 反射那样的功能，无法动态获取对象的类型。在 STL 中，使用了名为 traits 的方法来判断对象的类型，具体的做法，请看本系列的第五篇文章。

使用 C++ 无法避免与内存管理打交道。一般来说，通用意味着低效，因此语言原生的内存管理方式效果不会太好。《编程珠玑》里讲，很多情况下使用精心设计的内存池替代 malloc 管理的内存池能够显著提升程序的性能。STL 也不例外，它不仅实现了自己的 allocator （内存管理对象），而且也支持用户自己定义 allocator。这个系列的第六篇文章谈谈 STL 是如何管理内存的。

在这个系列的最后一篇文章中，我想简单介绍一下什么是 functor。functor 是重载了 =()= 运算符的对象，因此可以认为它是对象化了的函数，能够提升程序的灵活性。尽管和脚本语言的各种特性相比，STL 的 functor 要原始多了，但在 C++ 的世界里，functor 还是带来了飞一般的感觉。

这篇引子就写到这里，敬请关注这个系列的其它文章~
