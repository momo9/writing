# STL 系列的简单收尾

本文的作者是**深深爱着人类**的「我」。

STL 系列许久没有更新了，在这里给它简单收个尾

我建立了个人网站「momo9.me」，大家多去我那看看吧。点击「阅读原文」可以访问哈~

---

最初的时候， STL 系列是这么规划的

> 1. ~~introduction：引子~~
> 2. ~~vector 与 deque ：两种顺序容器~~
> 3. ~~map 与 hash_map ：STL 中树与哈希的实现~~
> 4. 算法：STL 中个人认为实现得比较巧妙的算法
> 5. traits：STL 中实现部分反射功能的一种方法
> 6. allocator ：STL 的内存管理
> 7. functor：简单说说什么是 functor

其中算法那部分，因为内容多，又被我拆成好几个部分，上次发了一篇拷贝的算法，目前总进度大概是一半左右。这个系列的文章，想做到的其实是希望能把每个地方都讲清楚，但公众号毕竟是公众号，达到的效果恐怕只是没有背景知识的读者终究是没看懂，有背景知识的读者看到的都是已经知道的东西。所以今天，我把这个系列收尾一下，脱离细节来聊聊剩下的内容。至于细节，大家还是找几本书来自己体会吧~

## 排序算法

STL 里的排序用的就是大家很熟悉的「快速排序」。大家都知道，从统计上来看，这种排序算法速度很快，但是对于某些特殊情况，快速排序有可能非常慢。

虽然不想说太多细节，这里还是简单回顾一下快速排序是怎么玩的。

![](quick-sort.jpg)

快速排序会在序列中随便找一个元素，称为「支点（pivot）」，然后保证支点左边的数都比支点小，右边的都比支点大。保证了这一点以后，再对支点左边和右边的序列分别排序，左右的序列分别排序以后，整个序列就是有序的。

左右两边的序列如何排序呢？采用一样的办法递归处理就可以了。找到支点，把序列分为两半，再在分出来的两个序列中继续找支点，虽然看起来始终没有排序，一直都在找支点，但考虑到当序列的长度不大于 3 的时候，找到支点就相当于进行了排序，最终这个序列会是有序的。

从统计上来看，支点差不多会位于序列的中间，每次需要处理的序列的长度都变为原来的一半，大概需要递归处理 `log2(n)` 次（假设序列长度为 n），排序就结束了，速度很快。但碰到倒霉的时候，每次支点都在边上，那就要 n 次处理以后，排序才会结束，这个速度就很慢了。

对于快速排序，STL 加入了三点改进：

* 三点中值

    既然支点没有选好会导致最坏情况的出现，那就选三个支点，然后取其中大小排在中间的那个，这样最坏情况出现的概率就小了。

* 最坏情况出现的时候使用「堆排序」

    如果算着算着，发现最坏情况还是出现了（递归的层次很深了），那就放弃快速排序找支点的办法，用堆排序对出现最坏情况的这个子序列进行排序。
    
    堆排序的性能比快速排序要差一些，但是一个数量级的。但堆排序不像快速排序那样会有最坏情况，性能稳定。

* 几乎有序后使用「插入排序」

    递归是比较耗费性能的。当每个子序列的长度都不太大的时候，整个序列已经几乎是有序的了，这时候不再进行快速排序，而是使用在序列几乎有序的情况下效果很好的插入排序。
    
    插入排序是一种速度比较慢的排序方式，但是它在序列几乎有序的情况下，却有很好的表现。

## traits

C++ 没有反射，这意味着在代码里拿到一个迭代器的时候，没法在代码里获取这个迭代器所指向的对象的类型，用来声明变量什么的。所谓 traits 就是 STL 为了解决这个问题的使用的一种 hack 方法。

最初看到这个觉得非常高端，现在回过头来再看，traits 完全就是为了 C++ 的语言特性而生的，对于 C++ 以外的借鉴意义并不是很大，而且我这半吊子的 C++ 水平又很难在这里讲明白，这里就略过不讲了。

## allocator

在应用开发的过程中使用 STL 容器的时候，就不太需要关心内存分配的事情了。但是内存的分配终究还是要做的，只是 STL 把它封装起来了。负责分配内存的，就是 allocator。

以前写 K&R 读后感的时候，讲过最最简单的内存分配（`malloc()` 的原理性实现，`malloc()` 是 C 语言中用来分配堆内存的函数）：因为向操作系统申请内存是非常耗费时间的，因此申请堆内存会一次申请比较大的量，放到内存池里用链表管理起来，释放了以后放回内存池，要用的时候也是从内存池里取，除非内存池里不够了，才会再向操作系统申请。

基本的原理是这样，但链表这个模型过于简单了，性能不好，真实标准库中的 `malloc()` 会进行很多的优化（这里就不提及这些优化了）。而 STL 的标准 allocator 则是在 `malloc()` 的基础上进行优化：

* 分成两级
    * 一次性申请比较大的（128 字节以上）的直接走 `malloc()`，交给标准库的内存池来管理
    * 而尺寸小的内存比较难管理，容易造成内存碎片，管理的开销也大，就由 STL 自己来管理
* STL 内存池
    * 维护 16 个链表，每个链表下面分别挂着大小为 8 字节、16 字节、24 字节、32 字节、……、120 字节、128 字节的内存块
    * 这些内存块都是整个取用的：比如需要 11 个字节，就给一个 16 字节的，还的时候也是整个归还
    * 链表还是那个链表，好处是什么呢？在最基本的模型中，因为链表下挂的内存块的大小都不一样，需要遍历整个链表来寻找合适大小的内存；而当链表中的内存块大小都一样的时候，直接使用第一个空闲的内存块就好，效率更高

## functor

软件设计很重要的是复用。比如定义一个加法函数，我们自然就会设计成 `plus(x, y)`，x 和 y 可以由用户传进去，这样这个函数就可以进行所有的加法运算，而不会设计成 `five_plus_three()` 这样的只能算 `5 + 3` 的函数，除了计算 `5 + 3 ` 以外毫无用处。

其实我们还可以进一步，设计成 `calculate(x, y, operation)`，连是加法还是减法也由用户传进去，而函数里只保留那些共性的东西。这就要求语言能够支持把「行为」也通过参数的方式传进去。

C 语言里用函数指针来支持这种功能，相当于函数可以是一个变量了。只不过，函数指针把函数签名给限制死了，灵活性也就不太高。比如我们要实现一个 map 函数，对一个数组里的所有元素都做一件相同的事情，那么应该这么定义。

    typedef int MapFun(int);
    
    void map(int* a, int size, MapFun call_back) {
        int i;
        for (i = 0; i < size, ++i) {
            a[i] = call_back(a[i]);
        }
    }

现在，只要符合 `MapFun` 这个签名的函数都可以作为 `map` 函数的 `call_back` 参数传进去，已经具有一定的灵活性，比如：

    int plus_one(int x) {
        return x + 1;
    }
    
    map(a, sizeof(a) / sizeof(int), plus_one);

假设我们不想要 `+ 1` 了，想要 `+ 2`，那就再写一个 `plus_two` 函数，把 `map` 的参数由 `plus_one` 换成  `plus_two` 就好，完全不用修改 `map` 本身。

那么如果我们希望这个 `+ n` 也能够通过参数传进去，变成 `int plus_n(int x, int n)` 呢？这是不可以的，因为函数签名改变了，不符合 `MapFun` 的定义。而去改变 `MapFun` 也不合适，因为这是 `plus_n` 个性的东西，而不是所有 map 行为共性的东西。

现在有两个办法：

* 函数指针经常定义成这样：`typedef int MapFun(int, void *)`，留一个无类型的指针专门用来传参数，具体实现这个函数的时候，再转换成需要的类型，甚至可以是用一个结构体传很多参数进来；这么做的话，编译器对类型的一些约束就别指望了
* 要么就把参数（`+ n` 的 n）作为全局变量，至于全局变量的坏处，我就不多啰嗦了

总之，都不怎么优雅……

STL 里用 functor 来支持「行为」的传递。这个名字比较忽悠人，但其实没有什么太神秘的，就是用一个对象把函数包裹起来作为参数传进去，然后内部调用 functor 的成员函数。

    class MapFun {
    public:
        virtual int map(int x) = 0;
    };
    
    class PlusFun : public MapFun {
    private:
        int n;
    public:
        PlusFun(int n) : n(n) {}
        virtual int map(int x) {
            return x + n;
        }
    };
    
    void map(int* a, int size, MapFun *call_back) {
        int i;
        for (i = 0; i < size; ++i) {
            a[i] = call_back->map(a[i]);
        }
    }
    
    PlusFun ps(1);
    map(a, sizeof(a) / sizeof(int), &ps);

这样虽然语法上变复杂了，但变成对象有变成对象的好处，functor 本身的特性和调用方对于接口的需求解耦了（而对于函数指针来说，调用方所需的接口就是函数指针本身），可以维护状态，可以通过继承等办法来扩展，灵活性就大多了。