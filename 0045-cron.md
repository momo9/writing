#定时任务历险记

![](0045-cron.png)

本文的作者是**深深爱着人类**的【我】。

调定时任务的时候踩过的坑。

我建立了个人网站【momo9.me】，大家多去我那看看吧。点击『阅读原文』可以访问哈~

---

因为消息不是很稳定，现在做的这个项目中很多异步的事情是通过定时任务来处理的。今天说说使用定时任务的过程中遇到的一些问题。

##出发

我们这个定时任务引擎的原理大概是这样：

* 每台机器（服务会部署在多台机器上）上运行的服务都会通过quartz定时任务去校验目标定时任务是否有心跳
* 如果没有心跳，每台机器都会尝试去抢占目标定时任务的执行权，先到先得
* 这样保证了只有一台机器在执行目标定时任务

有了这套定时任务引擎以后，开发的过程还是爽了不少的：一是定时任务比消息更可控，二是觉得一些逻辑（比如状态的更新）放在定时任务里之后，比放在流程里逻辑更清晰。

##迷路

人本来就是串行思考的，因此写串行的程序也会更得心应手。一个程序串行运行，出了什么问题，顺着流程也比较容易看出来。

定时任务的调试就要更费劲一些了，只能通过日志把定时任务的足迹记录下来，出了什么问题，再通过日志来分析。

一开始定时任务的日志是和其它日志一起的，定位问题比较困难。后来我们把定时任务的日志单独放到一个文件里，定位问题的工作，就轻松多了。

##失控

###事件

最可怕的事情是定时任务失去控制。

最开始的时候，我们在单元测试里也加了检查心跳的测试，结果出现了定时任务被单元测试集群的机器抢走的情况……这时候，日志看不到，修改了代码却没法生效（因为单测的机器上跑的是旧代码），定时任务失去控制，乱成一团。最后还是到单测的机器上把Java进程杀掉才解决的。从此再也不敢把定时任务相关的东西放在单测里了。

并且，一定要能控制定时任务。 其他人在他们的电脑上运行的程序也会和本地的程序抢定时任务的，万一被其他人抢走，就没法调试了。于是给定时任务加了配置项，如果配置项不满足条件，就不会去检查定时任务的心跳。在代码仓库里，把配置项关掉，只在自己需要调试的时候，把配置项打开。

之后一直还算顺利，直到有一天，离开一段时间后回来，发现本来本地运行着的定时任务被人抢走了。问题出在配置项上：实在是无法保证每次调试完之后都会记得把配置项关掉，因此打开的配置项被错误地提交到代码仓库里了。每个在本地起这段代码的人，都有可能抢占定时任务，而且，连对方跑的是什么代码都不知道（因为对方可能在本地进行修改）……

最终也没找到那次是谁把定时任务给抢走了，最后还是大家都去吃饭，回来后就好了。

###解决

首先是想要加上能够在runtime读写配置项的API。这样，代码里的配置项永远关闭定时任务，要调试的时候我在运行时打开就好。

读的很容易，作用只能说聊胜于无吧，能用API看到还是比查配置项方便点。

写的API，当时看了下代码，发现我们的项目里取配置项是在加载完成后读取一次，然后缓存下来的：这样是不容易修改的……于是很low地把自己常用的提交命令给重新引用了一下，加了一段检测配置项的shell，如果检测到配置项开启了定时任务，就不让提交了。

后来我才反应过来，弄个静态变量做定时任务的开关不就行了么……用配置项来初始化，然后通过API来进行开关。

这样应该是能把定时任务给控制住了。